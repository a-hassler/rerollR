#'Performs randomization tests on data frames generated by re_ functions.
#'
#'Performs randomization tests by successively pairing and comparing columns
#'from two "re_ made" data frames (compare columns with the same rank in their
#'respective data frames) with the results obtained after having randomly
#'assigned individuals/objects to the populations. Save the estimated p-values
#'in a data frame and produce a table and plot showing the distribution of these
#'p-values. (output: a list of objects containing: 1)"pvalues", a one column
#'data frame compiling all the p-values resulting from the tests; 2)"stats", a 1
#'x 3 data frame containing the percentages of tests resulting in a p-value
#'lower than 0.001, 0.01 and 0.05; 3)"plot", an optional ggplot2 graph showing
#'the distribution of p-values as a plot of density, histogram or both)
#'
#'@returns
#'A list of objects containing:
#'
#'1)"pvalues", a one column data frame compiling all the p-values resulting
#'from the tests. (nrow = ncol(p1) = ncol(p2))
#'
#'2)"stats", a 1 x 3 data frame containing the percentages of tests resulting
#'in a p-value lower than 0.001, 0.01 and 0.05
#'
#'3)"plot", an optional ggplot2 graph showing the distribution of p-values as
#'a plot of density, histogram or both.
#'
#'@inheritParams roll_ttest
#'@param p1,p2  (input: data frames from re_ functions) p1 and p2 inputs must be
#'  two data frames generated from re_ functions representing the two
#'  populations that the user wants to compare. p1 and p2 need to have the same
#'  number of columns and it is recommended to generate them using the same re_
#'  function (either re_boot or re_gauss) and same settings (notably n and
#'  boot.n).
#'@param nr (input: a positive integer) Specifies the number of randomizations
#'  (i.e random assignments) to be made for each pairs of column of p1 and p2
#'  data frame. Warning: regarding the typical size of re_ functions output
#'  (>1000 columns data frame), a nr >= 10 000, common for randomization tests,
#'  takes a considerable amount of computation time because the total number of
#'  randomization operations = nr x ncol(p1) (or nr x ncol(p2)). A nr<100 is
#'  advised for preliminary testing.
#'@param metric (input: "mean", "median", "t") Specifies the metric that will be
#'  monitored for each randomization. With "mean" monitors the absolute
#'  difference between the means of the populations. "median" monitors the
#'  absolute difference between the medians of the populations. "t" monitors the
#'  difference between the t statistic of the populations.
#'
#' @examples
#'#In the following examples, nr is maintained very small to allow quick
#'#preliminary tests. Such a low nr number produces coarse but fast results and
#'#plots.
#'#Performing proper randomization tests commonly require nr >= 10 000 but implies
#'#very lengthy computation time when multiplied by roll_rtest.
#'#(n randomization = nr x ncol(re_Pop1) = nr x ncol(re_Pop2))
#'
#'# With p1 and p2, two data frames generated by a re_ function (either re_gauss
#'# or re_boot) and same parameters. Attached re_Pop1 and re_Pop2 data frames
#'# have been generated by re_gauss with n=1000, a purposely small n, too small
#'# for proper analyses but allowing for quicker processing time for the purpose
#'# of this demonstration.
#'
#'#Only produces result data frames (no plot)
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="mean", do.plot=FALSE)
#'
#'#Produces an hybrid density + histogram plot (+ result data frames)
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="mean")
#'
#'#Produces a density plot (+ result data frames)
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="mean", histogram = FALSE)
#'
#'#Produces a histogram plot (+ result data frames)
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="mean", density=FALSE, histogram = TRUE)
#'
#'#Alternative metrics
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="median", density=FALSE, histogram = TRUE)
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="t", density=FALSE, histogram = TRUE)
#'
#'#Customized plot colors for density
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="mean", density=TRUE,
#'histogram =TRUE, fill.color=c("green","deepskyblue","blue","yellow"))
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="mean", density=TRUE,
#'histogram =FALSE, fill.color=c("green","deepskyblue","blue","yellow"))
#'#and histogram
#'roll_rtest(p1=re_Pop1, p2=re_Pop2, nr=10, metric="mean", density=FALSE,
#'histogram =TRUE, fill.color=c("green","deepskyblue","blue","yellow"))
#'@export

roll_rtest = function(p1, p2, nr, metric="mean", do.plot=T, density=T, histogram=T, fill.color=c("dodgerblue4","dodgerblue2","deepskyblue2","red")) {

#----------------------
#General requirement checks
if(missing(p1)) stop("You need to specify an input for p1. Provide a data frame generated by a re_ function (re_gauss or re_boot).")
if(missing(p2)) stop("You need to specify an input for p2. Provide a data frame generated by a re_ function (re_gauss or re_boot).")
if(ncol(p1)!=ncol(p2)) stop("Sorry, you need to perform this test with the same number of replicated populations (i.e. ncol(p1)==ncol(p2), same n within re_gauss or re_boot).")
if(missing(nr)) stop("You need to specify an input for nr. Provide a positive integer to define the number of randomization to perform for each randomization test. Note: The total number of randomization done for all randomization tests of one run of this function is equal to nr x ncol(p1), which can quickly ramp up computation time.")
if(nr != round(nr) || nr <= 0) stop("Warning, nr should be a positive integer. Provide a positive integer to define the number of randomization to perform for each randomization test. Note: The total number of randomization done for all randomization tests of one run of this function is equal to nr x ncol(p1), which can quickly ramp up computation time.")
if(metric!="mean" && metric!="median" && metric!="t") stop("Sorry, metric can only be equal to 'mean' (default), 'median' or 't'. Select the metric you want to compare in your randomization tests among these options.")
if(do.plot!=T && do.plot!=F) stop("Invalid input for do.plot argument. Possible input: TRUE (default) or FALSE")
if(do.plot==T && !requireNamespace("ggplot2", quietly = TRUE)) stop("You need to install ggplot2 to use rerollR plotting system.")
if(density!=T && density!=F) stop("Invalid input for density argument. Possible input: TRUE (default) or FALSE")
if(histogram!=T && histogram!=F) stop("Invalid input for histogram argument. Possible input: TRUE (default) or FALSE")
if(density==F && histogram==F && do.plot==T) stop("At least one of the following argument (density, histogram) need to be set to TRUE if do.plot==T.")
if(!is.vector(fill.color) || !is.character(fill.color) || length(fill.color) != 4) stop("fill.color can only be a vector of length==4 containing characters referring to colors (e.g. 'white', '#000000').")

x<-y<-p.value<-count<-fill<-NULL #create null variables to clear CMD check generated caused by ggplot2 data call structure and after_stat variables
#----------------------
#Core code
rres <-  data.frame(last=1:1) #create the df to store rtest results
k=1

#repeat randomization test
repeat{
  #merged col(x) pop1 and col(x) pop2 data together and keep original assignment
  Isodif_mrgd<- p1[k]
  Isodif_mrgd<- rbind(Isodif_mrgd, p2[k])
  Isodif_mrgd[(1:nrow(p1[k])),"assignment"] <-"P1"
  Isodif_mrgd[((nrow(p1[k])+1):(nrow(p1[k])+nrow(p2[k]))),"assignment"] <-"P2"

  k2=1
  #repeat randomization
  repeat{
    #random assignation as P1 or P2 pop
    random_liste <- sample(x=1:nrow(Isodif_mrgd), size=nrow(p1[k]),  replace = FALSE)
    Isodif_mrgd[random_liste,"assignment"] <-"P1"
    Isodif_mrgd[-random_liste,"assignment"]<-"P2"

    #Store P1 successive assignment
    if(k2==1){assignedP1 <- data.frame(last=1:nrow(Isodif_mrgd[Isodif_mrgd$assignment == "P1",]))} #create an initial df for P1 assign with the right row number (=nrow(df == "P1"))
    assignedP1[,"last"]<- NA
    assignedP1[,"last"]<- data.frame(last=Isodif_mrgd[Isodif_mrgd$assignment == "P1", 1])
    names(assignedP1)[ncol(assignedP1)] <- k2
    #Store P2 successive assignment
    if(k2==1){assignedP2 <- data.frame(last=1:nrow(Isodif_mrgd[Isodif_mrgd$assignment == "P2",]))} #create an initial df for P2 assign with the right row number (=nrow(df == "P2"))
    assignedP2[,"last"]<- NA
    assignedP2[,"last"]<- data.frame(last=Isodif_mrgd[Isodif_mrgd$assignment == "P2", 1])
    names(assignedP2)[ncol(assignedP2)] <- k2
    k2=k2+1
    if(nr<k2){break}
  }

  #create data frame/add column to store test results
  rres[,"last"]<- NA

  #Computes compared metric and store successive results
  #Compute ratio of randomly assigned means higher than original mean versus lower or equal for:
  #Difference between means or medians
  if(metric=="mean" || metric=="median") {
    metric.res <- data.frame("result" = apply(assignedP1[,1:ncol(assignedP1)],2,FUN=metric)-apply(assignedP2[,1:ncol(assignedP2)],2,FUN=metric))
    rres[,ncol(rres)]<-length(which(abs(apply(p1[k],2,FUN=metric)-apply(p2[k],2,FUN=metric)) <= abs(metric.res$result)))/nrow(metric.res)
  }

  #t stat
  if(metric=="t") {
    metric.res <- data.frame("result" = t.test(x=assignedP1[,1],y=assignedP2[,1], paired= FALSE)$statistic)
    k3=2
    repeat{
      metric.res <- rbind(metric.res, t.test(x=assignedP1[,k3],y=assignedP2[,k3], paired= FALSE)$statistic)
      k3=k3+1
      if(ncol(assignedP1)<k3){break}
    }
    rres[,ncol(rres)]<- length(which(abs(t.test(x=p1[k],y=p2[k], paired= FALSE)$statistic) <= abs(metric.res$result)))/nrow(metric.res)
  }

  #rename last result column
  names(rres)[ncol(rres)] <- k

  k=k+1
  if(ncol(p1)<k){break}
}

#----------------------
#Create a list summarizing the percentages of p value bellow 0.05, 0.01 and 0.001 (the ifelse(is.null) is here to force the return of a 0 instead of a numeric(0) when the number of a given category is 0))
res_list<- data.frame("p0.001"= length(rres[,rres <= 0.001])/length(rres)*100, "p0.01"= length(rres[,rres <= 0.01])/length(rres)*100, "p0.05"= length(rres[,rres <= 0.05])/length(rres)*100)# create a list of statistics about the tests
trres<-data.frame(p.value=t(rres))

#----------------------
#Plot results
if (do.plot==T) {

  d <- with(density(t(rres), from=0), data.frame(x, y))
  #conditional density parameters to improve readability for low p values and prevent density curve to start at x<0
  if(max(d$x)<0.001 & min(d$x)<0) {d <- with(density(trres$p.value, from=0, to=0.001), data.frame(x, y))}
  if(min(d$x)<0) {d <- with(density(trres$p.value, from=0), data.frame(x, y))}
  if(max(d$x)<0.001) {d <- with(density(trres$p.value, to=0.001), data.frame(x, y))}

  #scale density to the max of the histogram if combined density + histogram plot
  if(histogram==T) d[,"y"]<- d[,"y"]/max(d$y)*100*max(proportions(table(trunc(trres$p.value*10^3)/10^3)))

  #fill grading for histogram when density==F
  if(density==F && histogram == T) {
    rescol <- trres
    rescol[,"fill"] <- "D"
    if(any(rescol$p.value <= 0.05))rescol[rescol$p.value <= 0.05,]$fill <- "C"
    if(any(rescol$p.value <= 0.01))rescol[rescol$p.value <= 0.01,]$fill <- "B"
    if(any(rescol$p.value <= 0.001))rescol[rescol$p.value <= 0.001,]$fill <- "A"
  }

  #Plot
  resplot<- ggplot2::ggplot(data = d, mapping = ggplot2::aes(x = x, y = y)) +

    {if(density==T)ggplot2::geom_area(data=d, mapping = ggplot2::aes(x = x, y=ifelse(x >= 0.05, y, 0)), na.rm=T, fill =  fill.color[4], alpha=0.75)} +
    {if(density==T)ggplot2::geom_area(data=d, mapping = ggplot2::aes(x = x, y=ifelse(x <= 0.05 & x >= 0.01, y, 0)), na.rm=T, fill = fill.color[3])} +
    {if(density==T)ggplot2::geom_area(data=d, mapping = ggplot2::aes(x = x, y=ifelse(x <= 0.01 & x >= 0.001, y, 0)), na.rm=T, fill = fill.color[2])} +
    {if(density==T)ggplot2::geom_area(data=d, mapping = ggplot2::aes(x = x, y= ifelse(x <= 0.001 & x >= 0, y, 0)), na.rm=T, fill = fill.color[1])} +
    {if(density==T)ggplot2::geom_line(data=d, mapping = ggplot2::aes(x=x, y=y), na.rm=T)} +

    {if(density==T && histogram == T)ggplot2::geom_histogram(data = trres, ggplot2::aes(x=p.value, ggplot2::after_stat(count/sum(count)*100)), boundary=0, binwidth = 0.001, color="grey50", fill="white", alpha=0.1, na.rm = T)} +
    {if(density==F && histogram == T)ggplot2::geom_histogram(data = rescol, ggplot2::aes(x=p.value, ggplot2::after_stat(count/sum(count)*100), fill=fill), boundary=0, binwidth = 0.001, color="black", na.rm=T)} +
    {if(density==F && histogram == T)ggplot2::scale_fill_manual(breaks= c("A","B","C","D"), values = fill.color)} +
    {if(density==F && histogram == T)ggplot2::guides(fill="none")} +

    #label 0.05
    ggplot2::annotate("segment", x = 0.05, xend = 0.05, y = 0, yend = d[which(abs(d$x-0.05)==min(abs(d$x-0.05))),which( colnames(d)=="y" )]+max(d$y)*0.04)+
    ggplot2::annotate("text", x = 0.05, y = d[which(abs(d$x-0.05)==min(abs(d$x-0.05))),which( colnames(d)=="y" )]+max(d$y)*0.09, label= (paste0(c(round(res_list$p0.05,1)),"%")), cex = 5)+

    #label 0.01
    ggplot2::annotate("segment", x = 0.01, xend = 0.01, y = 0, yend = d[which(abs(d$x-0.01)==min(abs(d$x-0.01))),which( colnames(d)=="y" )]+max(d$y)*0.04)+
    ggplot2::annotate("text", x = 0.01, y = d[which(abs(d$x-0.01)==min(abs(d$x-0.01))),which( colnames(d)=="y" )]+max(d$y)*0.09, label= (paste0(c(round(res_list$p0.01,1)),"%")), cex = 5)+

    #label 0.001
    ggplot2::annotate("segment", x = 0.001, xend = 0.001, y = 0, yend = d[which(abs(d$x-0.001)==min(abs(d$x-0.001))),which( colnames(d)=="y" )]+max(d$y)*0.04)+
    ggplot2::annotate("text", x = 0.001, y = d[which(abs(d$x-0.001)==min(abs(d$x-0.001))),which( colnames(d)=="y" )]+max(d$y)*0.09, label= (paste0(c(round(res_list$p0.001,1)),"%")), cex = 5)+

    #specific label when all pvalues <= 0.001
    {if(all(trres$p.value <= 0.001)) ggplot2::annotate("text", x = 0.025, y= max(d$y)/2, label= (paste("All p.values are below 0.001")), cex = 4)}+

    #Axis and theme
    {if(density==T)ggplot2::scale_x_continuous(limits=c(0, ifelse(max(d$x) < 0.05, 0.05, max(d$x))))}+
    {if(density==F)ggplot2::scale_x_continuous(limits=c(0, ifelse(max(trres) < 0.05, 0.05, max(trres))))}+
    ggplot2::theme_bw()+
    {if(density==T && histogram==F)ggplot2::labs(title= paste("Randomization tests (",deparse(substitute(p1)), " Vs ", deparse(substitute(p2)),")"), y="Density", x= "randomization test results")}+
    {if(histogram==T)ggplot2::labs(title= paste("Randomization tests (",deparse(substitute(p1)), " Vs ", deparse(substitute(p2)),")"), y="Percentage (%)", x= "randomization test results")}

} #plot end

#----------------------
#Return results
ifelse(do.plot==T, all_res<-list(pvalues= trres, stats=res_list,  plot = resplot), all_res<-list(pvalues= trres, stats=res_list, plot = "No plot generated. do.plot set to F."))
return(all_res)

} #function end
