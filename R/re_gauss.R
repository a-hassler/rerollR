#'Use Gaussian random number generation to generate a data frame
#'
#'Takes a population of objects/individuals known through replicated
#'measurements of a given metric. Based on the values and distribution of the
#'measurements of each object/individual of this population (uncertainties
#'either provided in input or computed by the function), the function generates
#'new data for each object/individual of the population using a Gaussian random
#'number generation. These generations are centered on the mean of each
#'object/individual and conditioned by the dispersion of the replicated
#'measurements around their means (using the function rnorm from the package
#'stats). Each round of data generation represents an alternative population
#'(same number of objects/individuals with different values than the original
#'population) which are successively added as columns (one per iteration) in a
#'data frame.
#'
#'@returns
#'Return a data frame containing all created alternative populations.
#'For this data frame nrow is equal to the number of unique individual/object
#'with popm values (affected by na.popu), and ncol = n. Can serve as a input for
#'roll_ functions.
#'
#'@param data (input: NULL or a data frame) The input must be a data frame
#'  containing the population metric measurements (identified by the popm
#'  argument) and: if partitioned = F (default), a metric of the distribution of
#'  the object/individual replicated measurements (e.g. SD, SE or U values at
#'  the object/individual level, identified by the popu argument); or if
#'  partitioned = T, an identifier (a vector or column header) allowing to
#'  identify the objects/individuals composing the population (identified by the
#'  ID argument). If partitioned = F, u.conv = T and u = "SE" or "2SE", the
#'  input of the nm argument can also be a column header of data argument. Data
#'  argument input must be NULL (default) if popm, ID or popu inputs are not
#'  column headers (e.g. if ID = df$column_name).
#'@param popm (input: a column header from the data argument or a vector) The
#'  vector or column must contain the mean values of measurements for each
#'  object/individual of the population (if partitioned = F), or all replicated
#'  measurements of the objects/individuals of the population (if partitioned =
#'  T). The column or vector length must match the one of popu (if partitioned =
#'  F) or ID (if partitioned = T). popm, popu and/or ID must always have the
#'  same length and be ordered in the exact same way.
#'@param ID (input: NULL, a column header from the data argument or a vector)
#'  Only required if partitioned = T. The vector or column must contain
#'  PERFECTLY MATCHING identifiers (e.g. character strings, ID numbers)
#'  regarding popm input, to allow the function to identify objects/individuals
#'  within the population. The column or vector length must match the one of
#'  popm and be ordered in the exact same way.
#'@param popu (input: NULL, a column header from the data argument or a vector)
#'  Only required if partitioned = F. The vector or column must contain values
#'  from a metric of distribution or uncertainty of popm object/individual
#'  measurement values (e.g. SD, SE or U uncertainty values).
#'@param n (input: a positive integer) Specifies the number of alternative
#'  populations generated by the function and stored in the data frame in
#'  output. A n >= 10 000 is generally advised for reliable subsequent roll_
#'  testings, while n=100 or 1000 can be useful for quick preliminary testing.
#'@param partitioned (input: TRUE or FALSE) In partitioned = F mode (default),
#'  the intra-object/individual mean and dispersion or uncertainty values (e.g.
#'  SD, SE, U uncertainty values) are taken directly from popm and popu inputs,
#'  respectively. In such configuration, providing an input for ID is not
#'  necessary. Within the embed rnorm function (package stats), popu data are
#'  either used as such in rnorm (u.conv = F) or are converted to SD values
#'  before being processed (u.conv = T). In partitioned = T mode, the mean and
#'  standard deviation (SD) of each pool of object/individual popm values are
#'  calculated within re_gauss by grouping data with matching ID identifiers (NA
#'  values in popm are omitted; other NA values are generated when there is no
#'  replicate for a given object/individual measurement, see na.popu argument
#'  for how to deal with these NA values). These calculated mean and SD values
#'  are inputs for the rnorm function (package stats) embed in the re_gauss
#'  function.
#'@param u (input: NULL, "SD", "2SD", "SE", "2SE", "u", "U(k=2)", "U(k=3)")
#'  Specifies the nature of dispersion or uncertainty values contained in popu
#'  when partitioned = F (can be left as NULL when partitioned = T). "SD" (for
#'  standard deviation) is the standard mode, as the rnorm function (package
#'  stats) embed in re_gauss is designed to receive SD values as input. "2SD",
#'  "SE" and "2SE" are converted to SD values within re_gauss if u.conv = T and
#'  that appropriate input for the nm argument is provided (if u = "SE" or
#'  "2SE"). re_gauss cannot convert "u", "U(k=2)" or "U(k=3)" to SD values (even
#'  with u.conv = T). For custom uses, all of these possible inputs can directly
#'  serve as input for the embed rnorm function in replacement of SD values
#'  (with u.conv = F), but the user should acknowledge rnorm will still treat it
#'  as SD values which affect the meaning of the output.
#'@param u.conv (input: TRUE or FALSE) Argument only active when partitioned =
#'  F. Indicate if popu data should be converted in SD values from another form
#'  of dispersion or uncertainty metric (u.conv = T) or not (u.conv = F). For
#'  conversion from SE or 2SE values, specific input in the nm argument are
#'  required.
#'@param nm (input: NULL, a positive integer, a column header from the data
#'  argument or a vector) Input (other than NULL) only necessary when
#'  partitioned = F, u.conv = T and u = "SE" or "2SE". Specifies the number of
#'  replicates for each object/individual of the population. Necessary for
#'  converting popu into SD values from SE or 2SE values. Can be provided as a
#'  vector matching popm and popu in length and order, as a column header from
#'  data (if data = a data frame), or as a positive integer. This last option
#'  set the same nm (equal to the integer) for every object/individual of the
#'  population.
#'@param na.popu (input: NULL, a positive numeric value, "na.omit", "mean",
#'  "med", "min" or "max") Specifies the method to deal with NA values in
#'  dispersion/uncertainty data (within popu input or generated with
#'  partitioned=T), commonly generated when object/individual measurements have
#'  not been replicated (number of measurement = 1). If na.popu input is a
#'  positive numeric value, NA values are replaced by this numeric value.
#'  "na.omit" remove objects/individuals with NA values. If set to "mean",
#'  "med", "min" or "max", replace NA values by the calculated mean, median,
#'  minimum or maximum value (NA excluded) of the population, respectively.
#'  Values created by na.popu in replacement of NA values are processed like any
#'  other dispersion/uncertainty value regarding conversion to SD values (u.conv
#'  = T) and replacement through min.u related operations. Thus, consistency
#'  between the nature of popu and na.popu inputs is important.
#'@param min.u (input: NULL or a positive numeric value) Inactive if NULL
#'  (default). When set to a numeric value, all values in popu below the
#'  specified value of min.u are replaced by the value of min.u (e.g. for when
#'  popu is thought to be underestimated). This also applies for popu values
#'  generated by na.popu and SD values generated through partitioned = T. Values
#'  modified by min.u are processed like any other dispersion/uncertainty value
#'  regarding conversion to SD values (u.conv = T). Thus, consistency between
#'  the nature of popu and min.u inputs is important and must match u argument
#'  input (e.g. "SD", "2SD", etc.). When partitioned = T, min.u must be a
#'  standard deviation (SD) value.
#'
#' @examples
#'# Data frames mentioned in the example (Pop1, Pop1_agr) are contained in
#'# rerollR attached data.
#'
#'#Example of processing using re_gauss
#'
#'#For not aggregated data frame
#'re_gauss(data=Pop1, popm="Body_length", ID ="ID", n=100, partitioned = TRUE)
#'#equivalent to
#'re_gauss(popm=Pop1$Body_length, ID =Pop1$ID, n=100, partitioned = TRUE)
#'
#'#For aggregated data frame
#'re_gauss(data = Pop1_agr, popm="mean", popu = "sd", u = "SD", n=100)
#'#equivalent to
#'re_gauss(popm=Pop1_agr$mean, popu =Pop1_agr$sd, u = "SD", n=100)
#'@export

re_gauss = function(data=NULL, popm, ID=NULL, popu=NULL, n, partitioned=F, u=NULL, u.conv=F, nm=NULL, na.popu=NULL, min.u=NULL) {

#----------------------
#Requirement checks
loadNamespace("stats")
if(!is.null(data) && !is.data.frame(data)) stop("Stop, incorrect input for data argument. data argument can either be a data frame or set to NULL (default).")
if(missing(popm)) stop("popm argument missing. popm input can be a column header (e.g. data=df, popm='result') or a numeric vector (e.g. data=NULL, popm=df$result).")
if(missing(n)) stop("n argument missing. n must be a positive integer. It represents the number of populations generated by re_gauss. A number >= 10 000 is generally advised. A n < 10 000 (typically 100 or 1000) can be useful for quick preliminary testing.")
if(!is.numeric(n)) stop("n need to be a positive integer")
if(is.numeric(n)) {if(n != round(n) || n <= 0 || length(n) != 1) stop("n need to be a positive integer")}
if(partitioned==F && is.null(popu)) stop("Input for popu argument is required in partitioned=F mode (default). popu input can be a column header (e.g. data=df, popu='sd_values') or a numeric vector (e.g. data=NULL, popu=df$sd_values).")
if(is.null(u) && partitioned==F) stop("Input for u argument is required. Unless when partitioned = T, you need to specify the nature of the dispersion/uncertainty values around popm values provided in popu using the the argument u. Possible argument for u: 'SD', '2SD', 'SE', '2SE', 'u', 'U(k=2)', 'U(k=3). It is recommended to use SD values as an input for popu, or alternatively to provide 2SD, SE or 2SE values whith u.conv=T.")
if (is.null(data) && partitioned == T) {if (!is.vector(ID) || !is.vector(popm)) stop("Incorrect input. With partitioned = T, only the following configurations are accepted: 1) data argument is NULL (default) while popm and ID arguments are vectors matching in length and order (e.g. popm=df$result, ID=df$sample_name); OR 2) data is a data frame while ID and popm are column headers of this data frame (e.g. data= df, popm='result', ID= 'sample_name').")}
if (is.null(data) && partitioned == F) {if (!is.vector(popu) || !is.vector(popm)) stop("Incorrect input. With partitioned = F, only the following configurations are accepted: 1) data argument is NULL (default) while popm and popu are vectors matching in length and order (e.g. popm=df$result, popu=df$sd_values); OR 2) data argument is a data frame while popm and popu are column headers of this data frame (e.g. data= df, popm='result', popu= 'sd_values').")}
if (!is.null(data)) {if (!is.character(popm) || length(popm) != 1) stop("Incorrect input for popm argument. When data argument is a data frame, popm argument must be a column header of this data frame (e.g. popm = 'result').")}
if (!is.null(data)&& partitioned == T) {if (!is.character(ID) || length(ID) != 1) stop("Incorrect input for ID argument. When data argument is a data frame, ID argument must be a column header of this data frame (e.g. ID = 'sample_name').")}
if (!is.null(data)&& partitioned == F) {if (!is.character(popu) || length(popu) != 1) stop("Incorrect input for popu argument. When data argument is a data frame, popu argument must be a column header of this data frame (e.g. popu = 'sd_values').")}
if(!is.null(nm)) {if(u.conv==F || partitioned==T || u != "SE" && u != "2SE") warning("nm argument has no use in the current configuration, because partitioned = T and/or u.conv = F and/or u is different from 'SE' or '2SE'. It can be let to NULL (default).")}
if(!is.null(na.popu) && !is.numeric(na.popu) && na.popu != "na.omit" && na.popu != "mean" && na.popu != "med" && na.popu != "min" && na.popu != "max") stop("Stop, incorrect input for na.popu argument. Only the following inputs are possible: NULL, 'na.omit', 'mean', 'med', 'min', 'max' or a positive numeric value.")
if(is.numeric(na.popu)){if(na.popu <= 0 || length(na.popu) != 1) stop("Stop, incorrect input for na.popu argument. Only the following inputs are possible: NULL, 'na.omit', 'mean', 'med', 'min', 'max' or a positive numeric value.")}

#partitioned == F
if(partitioned==F){
  if(!is.null(ID)) warning("ID input has no use when partitioned = F. It can be let to NULL.")
  if(u=="SD" && u.conv==T) warning("u.conv = T has no impact on function results because u='SD'. u.conv can be set to FALSE (default).")
  if(is.null(data) && length(popm) != length(popu)) stop("Stop, as vectors popm and popu must match in length and data order.")
  if(!is.null(nm) && u.conv==T) {
    if(u == "SE" || u == "2SE") {
      if(length(nm)==1 && nm<=0) stop("Stop, when nm input is a discrete value it must be a positive integer.")
      if(length(nm)>1 && any(nm<=0)) stop("Stop, nm input cannot contain 0 or negative values.")
      if(length(nm)>1 && length(nm) != length(popm)) stop("Stop, when nm input is a vector it must match popm and popu length and data order.")
    }}
  if(is.null(nm) && u.conv==T) {
    if(u=="SE") stop("You need to specify an input for nm argument to allow re_gauss to handle the conversion from SE to SD values (u.conv=T)")
    if(u=="2SE") stop("You need to specify an input for nm argument to allow re_gauss to handle the conversion from 2SE to SD values (u.conv=T)")
  }
}

#partitioned == T
if(partitioned==T){
  if(is.null(ID)) stop("partitioned=T but ID is NULL. You cannot aggregate partitioned replicates without providing a valid input for the ID argument. To identify partitioned replicates, ID must be a column header from the data frame of the data argument or a numeric vector matching the length and order of popm.")
  if(!is.null(popu)) warning("partitioned=T imply popu values are calculated within re_gauss as SD values and overwrite popu input. In this configuration popu has no impact on the output of re_gauss and can be set to NULL (default).")
  if(!is.null(u)) stop("partitioned=T imply popu values are calculated within re_gauss as SD values and overwrite popu input. In this configuration u has no impact on the output of re_gauss and can be set to NULL (default).")
  if(u.conv==T) warning("partitioned=T imply popu values are calculated within re_gauss as SD values and overwrite popu input. In this configuration u.conv has no impact on the output of re_gauss and can be set to FALSE (default).")
  if(is.null(data) && length(popm) != length(ID)) stop("Stop, as vectors popm and ID must match in length and data order.")
}

#----------------------
#Input homogenization to vector default structure
if (!is.null(data) && partitioned==F) {
  data<-data[!is.na(data[,popm]),]
  popm=data[,popm]
  popu=data[,popu]
  if(is.character(nm)) nm<-data[,nm]
  if(length(nm) == 1 && is.numeric(nm)) nm<-rep(nm, length(popm)) #if to allow forcing a constant nm value
}

if (partitioned==T && !is.null(ID)) {
  if(is.null(data)) {
    agg<-aggregate(popm, by=list(ID), FUN=mean, na.rm=T)
    colnames(agg) <- c("ID", "popm")
    agg$popu<-aggregate(popm, by=list(ID), FUN=sd)[,2]
    agg$nm<-aggregate(popm, by=list(ID), FUN=length)[,2]
  }
  if(!is.null(data)) {
    agg<-aggregate(data[,popm], by=list(data[,ID]), FUN=mean, na.rm=T)
    colnames(agg) <- c("ID", "popm")
    agg$popu<-aggregate(data[,popm], by=list(data[,ID]), FUN=sd)[,2]
    agg$nm<-aggregate(data[,popm], by=list(data[,ID]), FUN=length)[,2]
  }
  popm=agg$popm
  popu=agg$popu
  nm=agg$nm
}

#----------------------
#u management
#Forced discrete and homogeneous nm
if(length(nm) == 1) nm<- rep(nm, length(popm))

#na.popu action
if(sum(is.na(popu)) >= 1 && is.null(na.popu)) stop("Provided popu input contain NA values. Please specify how NA values have to be treated using the na.popu argument.")
if(!is.null(na.popu)) {
  if(na.popu=="na.omit") {
    if(!is.null(nm) && u.conv==T && u == "SE" || !is.null(nm) && u.conv==T && u == "2SE") {df<-na.omit(data.frame(popm=popm, popu=popu, nm=nm))} else {df<-na.omit(data.frame(popm=popm, popu=popu))}
    if(!is.null(nm) && u.conv==T) { if(u == "SE" || u == "2SE") popm <- df$popm ; popu <- df$popu ; nm <- df$nm}
    if(is.null(nm)) {popm <- df$popm ; popu <- df$popu}
  }
  if(is.numeric(na.popu) && length(na.popu) == 1) popu[is.na(popu)] <- na.popu #provide a range of easy possible customization for the user regarding the treatment of NA values in popu
  if(na.popu=="mean") popu[is.na(popu)] <- mean(popu, na.rm=T)
  if(na.popu=="med") popu[is.na(popu)] <- median(popu, na.rm=T)
  if(na.popu=="min") popu[is.na(popu)] <- min(popu, na.rm=T)
  if(na.popu=="max") popu[is.na(popu)] <- max(popu, na.rm=T)
}

#min.u action
if(!is.null(min.u)){
  if(is.numeric(min.u)) popu[popu<min.u] <- min.u
  if(min.u=="mean") popu[popu<mean(popu)] <- mean(popu)
  if(min.u=="med") popu[popu<median(popu)] <- median(popu)
  if(min.u=="min") popu[popu<min(popu)] <- min(popu)
  if(min.u=="max") popu[popu<max(popu)] <- max(popu)
  if(!is.numeric(min.u) && min.u!="mean" && min.u!="med" && min.u!="min" && min.u!="max") stop("Invalid input for min.u. If you wish to set a minimum value for popu values please specify a numeric value for min.u or set min.u to one of the following arguments: 'mean', 'med', 'min', or 'max'.")
}

#Identify the nature of the uncertainty (SD, 2SD, SE, 2SE, u, U(k=2), U(k=3)), if u.convert=TRUE convert 2SD, SE or 2SE into SD values
if (u !="SD" && partitioned==F) {
  if(u.conv==F) warning("Proceed with caution! By setting u.conv to FALSE and providing uncertainties other than SD values you are forcing the random generation of Gaussian distributed values based on exotic parameters. This possibly prevent further meaningful interpretations from subsequent tests performed using roll_ functions.")
  if (u !="2SD"&& u !="SE"&& u !="2SE"&& u !="u"&& u !="U(k=2)"&& u !="U(k=3)") stop("Invalid input for argument u.You need to specify the nature of popu values (possible argument for u: SD, 2SD, SE, 2SE, u, U(k=2), U(k=3)). It is recommended to use SD values as an input for popu, or alternatively to provide 2SD, SE or 2SE values with u.conv=T.")

  if(u.conv==T) {
    if(u=="2SD") popu <- popu/2
    if(u=="2SE") {
      if(is.null(nm)) stop("nm argument is NULL. This function primarily use the standard deviation (SD) as input for random Gaussian number generation. If you want standard error (SE or 2SE) inputs to be converted in SD within re_gauss, please provide the number of replicated measures for each object/individual of the population, either as a numeric value relevant to all objects/individuals of the population (nm = x), as a numeric vector of the same length and order than popm (nm = df$replicates_number), as a column header from the data argument input (data = df, nm = 'replicates_number').")
      popu <- popu*sqrt(nm)/2
    }
    if (u=="SE") {
      if(is.null(nm)) stop("nm argument is NULL. This function primarily use the standard deviation (SD) as input for random Gaussian number generation. If you want standard error (SE or 2SE) inputs to be converted in SD within re_gauss, please provide the number of replicated measures for each object/individual of the population, either as a numeric value relevant to all objects/individuals of the population (nm = x), as a numeric vector of the same length and order than popm (nm = df$replicates_number), as a column header from the data argument input (data = df, nm = 'replicates_number').")
      popu <- popu*sqrt(nm)
    }
    if(u=="u") stop("Sorry, this function cannot convert u uncertainties into SD values. You should either provide SD values for popu, or 2SD, SE, 2SE values with u.conv = T, or set u.conv = F.")
    if(u=="U(k=2)" || u=="U(k=3)") stop("Sorry, this function cannot convert U uncertainties into SD values. You should either provide SD values for popu, or 2SD, SE, 2SE values with u.conv = T, or set u.conv = F.")
  }
}

#----------------------
#Core code

popm.r <- data.frame(last=1:length(popm)) #create the df to store rnorm generated results

#data frame loop
k=1  #create k to name each iteration in the data frame and break the repeat loop when k=n
repeat{
  popm.r[,"last"]<- NA
  popm.r[,ncol(popm.r)]<- rnorm(nrow(!is.na(popm.r)), mean=popm, sd=popu)
  names(popm.r)[ncol(popm.r)] <- k
  k=k+1
  if(n<k){break}
}

return(popm.r)

} #end
