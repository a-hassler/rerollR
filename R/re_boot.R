#'Use bootstrapping to generate a data frame
#'
#'Takes a population of objects/individuals known through replicated
#'measurements of a given metric. The function makes random sampling with
#'replacement (bootstrapping) within each object/individual data in order to
#'produce alternative populations.
#'
#'@returns
#'Return a data frame containing all created alternative populations.
#'For this data frame nrow is equal to the number of unique individual/object
#'with popm replicated values, and ncol = n. Can serve as a input for
#'roll_ functions.
#'
#'@param data (input: NULL or a data frame) The input must be a data frame
#'  containing the population metric measurements (identified by the popm
#'  argument) and an identifier (a vector or column header) allowing to identify
#'  the objects/individuals composing the population (identified by the ID
#'  argument). Data argument input must be NULL (default) if popm and ID inputs
#'  are vectors (e.g. data = NULL, popm = df$result, ID = df$column_name) and
#'  should be a data frame if popm and ID inputs are column headers of this data
#'  frame (e.g. data = df, popm = 'result', ID = 'column_name').
#'@param popm (input: a column header from the data argument or a vector) The
#'  vector or column must contain all replicated measurements of each
#'  object/individual of the population. These data are the one that will be
#'  iteratively bootstrapped. NA values within popm input are omitted. The
#'  column or vector length of popm must match the one of ID and be ordered in
#'  the exact same way.
#'@param ID (input: NULL, a column header from the data argument or a vector)
#'  The vector or column must contain PERFECTLY MATCHING identifiers (e.g.
#'  character strings, ID numbers) regarding popm input, to allow the function
#'  to identify objects/individuals within the population. The column or vector
#'  length must match the one of popm and be ordered in the exact same way.
#'@param n (input: a positive integer) Specifies the number of alternative
#'  populations generated by the function and stored in the data frame in
#'  output. A n >= 10 000 is generally advised for reliable subsequent roll_
#'  testings, while n=100 or 1000 can be useful for quick preliminary testing.
#'@param boot.n (input: a positive integer) Specifies the number of random
#'  sampling with replacement performed within popm data for each of the
#'  object/individual and each generation of alternative population. With boot.n
#'  = 1 (default) the function takes only one measurement per object/individual
#'  for each generation of alternative population. At boot.n >= 2, each
#'  object/individual of each generated population become the mean of boot.n
#'  numbers of bootstrap sampling from the original object/individual
#'  measurement replicates.
#'
#' @examples
#'# The data frame mentioned in the example (Pop1) is contained in
#'# rerollR attached data.
#'
#'#Example of processing using re_boot
#'
#'#For not aggregated data frame (the only possibility)
#'re_boot(data=Pop1, popm="Body_length", ID ="ID", n=1000, boot.n = 1)
#'#equivalent to
#'re_boot(popm=Pop1$Body_length, ID =Pop1$ID, n=1000, boot.n = 1)
#'
#'#With averaging after boot.n = x bootstrapping per individual/object
#'re_boot(data=Pop1, popm="Body_length", ID ="ID", n=1000, boot.n = 10)
#'@export

re_boot = function(data=NULL, popm, ID, n, boot.n=1) {

#----------------------
#Requirement checks
if(!is.null(data) && !is.data.frame(data)) stop("Stop, incorrect input for data argument. data can either be a data frame or set to NULL (default).")
if(missing(popm)) stop("popm argument missing. popm input can be a column header (e.g. data=df, popm='result') or a numeric vector (e.g. data=NULL, popm=df$result).")
if(missing(ID)) stop("ID argument missing. ID input can be a column header (e.g. data=df, ID='sample_name') or a numeric vector (e.g. data=NULL, ID=df$sample_name).")
if (length(ID) != length(popm)) stop("Stop, ID and popm inputs do not match. Vector or column lengths are different.")
if (is.null(data)) {if (!is.vector(ID) || !is.vector(popm)) stop("Incorrect popm and/or ID inputs. Only the following configurations are accepted: 1) data is NULL (default) while ID, and popm are vectors matching in length and order (e.g. data=NULL, popm=df$result, ID=df$sample_name); OR 2) data is a data frame and ID and popm column headers of this data frame (e.g. data = df, popm = 'result', ID = 'column_name').")}
if (!is.null(data)) {if (!is.character(popm) || length(popm) != 1) stop("Incorrect input for popm argument. When data is a data frame (i.e. data != NULL), popm should be a column header of this data frame (e.g. data=df, popm='result').")}
if (!is.null(data)) {if (!is.character(ID) || length(ID) != 1) stop("Incorrect input for ID argument. When data is a data frame (i.e. data != NULL method), ID should be a column header of this data frame (e.g. data=df, ID='sample_name').")}
if(missing(n)) stop("n argument missing. You have to specify the number of iteration/generated population of re_boot (i.e. the number of column contained in the data frame in output).")
if(!is.numeric(n)) stop("n need to be a positive integer")
if(is.numeric(n)) {if(n != round(n) || n <= 0 || length(n) != 1) stop("n need to be a positive integer")}
if(!is.numeric(boot.n)) stop("Stop, boot.n argument must be a positive integer.")
if(is.numeric(boot.n)) {if(boot.n != round(boot.n) || boot.n <= 0) stop("Stop, boot.n argument must be a positive integer.")}
if(boot.n<=0) stop("boot.n cannot be set to 0 or less.")

#----------------------
#Input homogenization to data frame default structure
if (is.null(data) && is.vector(ID) && is.vector(popm)) {
  data=data.frame(ID=ID, popm=popm)   #create data frame from vectors if not supplied
  ID="ID" ; popm="popm"               #change vectors to corresponding data column name
}

data<-data[!is.na(data[,popm]),]    #delete rows with NA values in popm

#----------------------
#Core code

popm.r <-  data.frame(last=1:nrow(data[!duplicated(data[,ID]), ])) #create the df to store re-sampled results

#data frame loop
k=1   #create k to name each iteration in the data frame and break the repeat loop when k=n
repeat{
  popm.r[,"last"]<- NA
  k2=1
  popm.boot <-  data.frame(last=1:nrow(data[!duplicated(data[,ID]), ])) #create the df to store up to boot.n re-sampled results
  repeat{
    popm.boot[,"last"]<- NA
    d<-data[sample(1:nrow(data)), ]           #shuffle the rows of the data frame in input
    d<-d[!duplicated(d[,ID]), ]               #keep a single replicate measurement for each object/individual (identified with ID argument)
    d<-d[order(d[,ID]), ]                     #order the data frame according to the ID column (allow to not mix object/individual data together)
    popm.boot[,ncol(popm.boot)]<- d[,popm]    #saves results in popm.boot
    names(popm.boot)[ncol(popm.boot)] <- k2
    k2=k2+1
    if(boot.n<k2){break}
  }
  popm.r[,ncol(popm.r)]<- rowMeans(popm.boot) #take the mean of each sample for this iteration, save it as a column in the final data frame
  names(popm.r)[ncol(popm.r)] <- k
  k=k+1
  if(n<k){break}
}

return(popm.r)

} #end
